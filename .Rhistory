Weight = mean (HeadWt),
sd = sd(HeadWt),
n = length(HeadWt))
head(summarise4)
summarise5 <- ddply(c5, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n= sum(!is.na (HeadWt)))
head(summarise5)
# 复制cabbages并移除同时包含c52和d21的行
c6 <- subset(c5, !( Cult=="c52" & Date=="d21"))
c6a <- ddply(c6, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na (HeadWt)))
c6a
summarise5 <- ddply(c5, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n= sum(!is.na (HeadWt)))
summarise5
c5 <- cabbages
c5$HeadWt[c(1,20,45)] <- NA  #  某些数据值赋值为NA
summarise4 <- ddply(c5, c("Cult", "Date"), summarise,
Weight = mean (HeadWt),
sd = sd(HeadWt),
n = length(HeadWt))
summarise4
summarise3 <- ddply(c3, c("Cult", "Date"), summarise,
Weight = mean(HeadWt),
sd = sd(HeadWt),
n = length(HeadWt))
summarise3
c3
head(c3)
library(MASS) # 为了使用数据集
library(plyr)
summarise1 <- ddply(c3, c("Cult","Date"), summarise,
Weight = mean(HeadWt), VitC = mean(VitC))
summarise1
cb2 <- ddply(c3, c("Cult","Date"), transform,
DevWt = HeadWt - mean(HeadWt), DevVitC = VitC - mean(VitC))
cb2
cb2 <- ddply(c3, c("Cult","Date"), transform,
DevWt = HeadWt - mean(HeadWt), DevVitC = VitC - mean(VitC))
head(cb2)
# 复制cabbages并移除同时包含c52和d21的行
c6 <- subset(c5, !( Cult=="c52" & Date=="d21"))
c6a <- ddply(c6, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na (HeadWt)))
c6a
# 绘图
ggplot(c2a, aes(x=Date, fill=Cult, y=Weight)) + geom_bar(position="dodge")
# 复制cabbages并移除同时包含c52和d21的行
c6 <- subset(c5, !( Cult=="c52" & Date=="d21"))
c6a <- ddply(c6, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na (HeadWt)))
c6a
# 绘图
ggplot(c6a, aes(x=Date, fill=Cult, y=Weight)) + geom_bar(position="dodge")
?geom_bar
# 复制cabbages并移除同时包含c52和d21的行
c6 <- subset(c5, !( Cult=="c52" & Date=="d21"))
c6a <- ddply(c6, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na (HeadWt)))
c6a
# 绘图
ggplot(c6a, aes(x=Date, fill=Cult, y=Weight)) + geom_bar(stat = "identity",position="dodge")
c6b <- ddply(c6, c("Cult", "Date"), .drop=FALSE, summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na (HeadWt)))
c6b
# 绘图
ggplot(c6b, aes(x=Date, fill=Cult, y=Weight)) + geom_bar(stat = "identity",position="dodge")
library(MASS) # 为了使用数据集
library(plyr)
c7 <- ddply(cabbages, c("Cult", "Date"), summarise,
Weight = mean(HeadWt, na.rm=TRUE),
sd = sd(HeadWt, na.rm=TRUE),
n = sum(!is.na(HeadWt)),
se = sd/sqrt(n))
c7
ciMult <- qt(.975, ca$n-1)
ciMult <- qt(.975, c7$n-1)
ciMult
casci <- casse * ciMult
casci <- c7$se * ciMult
ca$ci <- c7$se * ciMult
c7$ci <- c7$se * ciMult
c7$ci
c7$ci <- c7$se * ciMult
c7
c8$ci95 <- c7$se * qt(.975,c7$n)
c8 <- c7
c8$ci95 <- c8$se * qt(.975,c7$n)
c8
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
#重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult
return(datac)
}
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
#重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt", с("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
#重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt", с("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
#重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
# 重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
# 重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult1 <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult1
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
# 重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult1 <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult1
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
summarySE
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
# 重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult1 <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult1
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages, !(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
c8
summarySE <- function(data=NULL, measurevar, groupvars=NULL,
conf.interval=.95, na.rm=FALSE,.drop=TRUE){
require (plyr)
# 新版本的length可以处理缺失值: 如果na.rm==T，则排除缺失值
length2 <- function(x, na.rm=FALSE){
if (na.rm) sum(!is.na(x))
else       length(x)
}
# 汇总
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col, na.rm){
c(n = length2(xx[,col], na.rm=na.rm),
mean = mean (xx[,col], na.rm-na.rm),
sd = sd(xx[,col],na.rm=na.rm)
)
},
measurevar,
na.rm
)
# 重命名"mean"列
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$n)  # 计算均值的标准误差
# 标准误差的置信区间乘数
# 为置信区间计算t统计量
# 比如，如果conf.interval是.95，就使用.975 (上/下)，并且
# 使用df=n-1，或如果n==0，则df=0
ciMult1 <- qt(conf.interval/2+.5, datac$n-1)
datac$ci <- datac$se * ciMult1
return(datac)
}
# 这里的应用例子计算99%的置信区间，并且可以处理缺失值和空缺组合
# 移除c52和d21对应的所有行
c8 <- subset(cabbages,!(Cult=="c52" & Date=="d21"))
# 将一些值设置为NA
c8$HeadWt[c(1,20,45)] <- NA
summarySE(c8, "HeadWt",c("Cult", "Date"), conf.interval=.99,
na.rm=TRUE,.drop=FALSE)
library(gcookbook） # 为了使用数据
library(gcookbook) # 为了使用数据
anthoming
library(reshape2)
melt(anthoming, id.vars="angle", variable.name="condition", value.name="count")
library(reshape2)
melt(anthoming, id.vars="Angle", variable.name="condition", value.name="count")
drunk
melt(drunk, id.vars="sex", measure.vars=c("0-29","30-39"),
variable.name="age", value.name="count")
plum_wide
plum_wide
melt(plum_wide, id.vars=c("length","time"), variable.name="survival",value.name="count")
# 创造数据的一个副本
co <- corneas
Co
# 创造数据的一个副本
co <- corneas
co
# 创造数据的一个副本
co <- corneas
co
# 添加标识列
co$id <- l:nrow(co)
# 创造数据的一个副本
co <- corneas
co
# 添加标识列
co$id <- 1:nrow(co)
melt(co, id.vars="id", variable.name="eye", value.name="thickness")
library(gcookbook) # 为了使用数据集
plum
library(reshape2)
dcast(plum, length + time ~ survival, value.var="count")
dcast(plum, time ~ length + survival, value.var="count")
# 查看时间序列对象nhtemp
nhtemp
# 查看时间序列对象nhtemp
nhtemp
# 得到每次观测的时间
as.numeric(time(nhtemp))
# 查看时间序列对象nhtemp
nhtemp
# 得到每次观测的时间
as.numeric(time(nhtemp))
# 得到每次观测的值
as.numeric(nhtemp)
# 查看时间序列对象nhtemp
nhtemp
# 得到每次观测的时间
as.numeric(time(nhtemp))
# 得到每次观测的值
as.numeric(nhtemp)
# 把它们放进一个数据框中
nht <- data.frame(year=as.numeric(time(nhtemp)), temp=as.numeric(nhtemp))
nht
# 查看时间序列对象nhtemp
nhtemp
# 得到每次观测的时间
as.numeric(time(nhtemp))
# 得到每次观测的值
as.numeric(nhtemp)
# 把它们放进一个数据框中
nht <- data.frame(year=as.numeric(time(nhtemp)), temp=as.numeric(nhtemp))
head(nht)
presidents
head(presidents)
presidents6 <- presidents
head(presidents6)
presidents
pres_rating <- data.frame(
year = as.numeric(time(presidents)),
rating  = as.numeric(presidents))
pres_rating
pres_rating <- data.frame(
year = as.numeric(time(presidents)),
rating  = as.numeric(presidents))
head(pres_rating)
