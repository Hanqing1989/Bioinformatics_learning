n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit4), names(hatvalues(fit4)))
}
hat.plot(fit4)
cutoff <- 4/(nrow(states) - length(fitscoefficients)-2)
cutoff <- 4/(nrow(states) - length(fit$coefficients)-2)
plot(fit4,which=4,cook.levels=cutoff)
abline(h=cutoff,lty=2,col="red")
library(car)
avPlots(fit4,ask=FALSE,id.method="identify")
library(car)
influenceplot(fit4,id.method="identify",main="Influence Plot",sub="Circle size is proportional to Cook's distance")
library(car)
influencePlot(fit4,id.method="identify",main="Influence Plot",sub="Circle size is proportional to Cook's distance")
library(car)
boxTidwell(Murder~Population+Illiteracy,data = states)
library(car)
summary(powerTransform(states$Murder))
library(car)
boxTidwell(Murder~Population+Illiteracy,data = states)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
anova(fit7,fit4)
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
AIC(fit4,fit7)
library(MASS)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
stepAIC(fit4,direction="backward")
install.packages('leaps')
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot (leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
subsets
?subsets
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
install.packages('bootstrap')
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fitsmodel[,2:ncol(fit$model)]
y <- fitsmodel[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fitsfitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fitsmodel[,2:ncol(fit$model)]
y <- fitsmodel[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,result$scv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit4 <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x) %*% fit4$coef}
x <- fit4$model[,2:ncol(fit4$model)]
y <- fit4$model[,1]
results <- crossval(x,y,theta.fit4,theta.predict,ngroup=k)
r2 <- cor(y,fit4$fitted.values)^2
r2cv <- cor(y,results$cv.fit4)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
zstates <- as.data.frame(scale(states))
zfit <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=zstates)
coef(zfit)
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar,2:nvar]
rxy <- R[2:nvar,1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda^2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^2)
rawwgt <- lambdasq %*% beta^2
import <- (rawwgt / rsquare)*100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1,drop=FALSE]
dotchart(import$Weights,labels=row.names(import),
xlab="% of R-Square",pch=19,main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=",round(rsquare,digits=3)),...)
return(import)
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
relweights(fit4,col="blue")
library(effects)
plot(effect("hp:wt",fit5,,list(wt=c(2.2,3.2,4.2))),multiline=TRUE)
cutoff <- 4/(nrow(states) - length(fit4$coefficients)-2)
plot(fit4,which=4,cook.levels=cutoff)
abline(h=cutoff,lty=2,col="red")
install.packages('rrcov')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(mvoutlier)
outliers <- aq.plot(y)
center <- colMeans(y)
center <- colMeans(y)
library(MASS)
attach(UScereal)
shelf <- factor(shelf) # 将shelf变量转换为因子变量, 从而使它在后续分析中能作为分组变量
y <- cbind(calories, fat, sugars) # cbind() 函数将三个因变量(卡路里、脂肪和糖)合并成一个矩阵
aggregate(y, by=list(shelf), FUN=mean) # aggregate()函数可获取货架的各个均值
options(digits = 3)
cov(y) # cov()则输出各谷物间的方差和协方差
fit <- manova(y ~ shelf) # manova()函数能对组间差异进行多元检验。
summary(fit)
summary.aov(fit) # 输出单变量结果。由于多元检验是显著的，可以使用summary.aov()函数对每一个变量做单因素方差分析
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
text(coord$x, coord$y,
row.names(UScereal),
cex=1, pos=2, col="red")
library(mvoutlier)
outliers <- aq.plot(y)
outliers
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(rrcov)
Wilks.test(y,shelf,method="mcd")
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(multcomp)
levels(cholesterol$trt)
fit.aov <- aov(response ~ trt,data=cholesterol)
summary(fit.aov)
fit.lm <- lm(response ~ trt,data=cholesterol)
summary(fit.lm)
contrasts(cholesterol$trt)
install.packages('pwr')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(pwr)
pwr.t.test(d=.8, sig.level=.05, power=.9, type="two.sample",alternative="two.sided")
pwr.t.test(n=20, d=.5, sig.level=.01, type="two.sample",alternative="two.sided" )
pwr.anova.test(k=5, f=.25, sig.level=.05, power=.8)
pwr.r.test(r=.25, sig.level=.05, power=.90, alternative-"greater")
pwr.r.test(r=.25, sig.level=.05, power=.90, alternative="greater")
pwr.f2.test(u=3, f2=0.0769, sig.level=0.05, power=0.90)
pwr.2p.test(h=ES.h(.65,.6), sig.level=.05, power=.9,alternative="greater")
prob <- matrix(c(.42, .28, .03, .07, .10, .10), byrow=TRUE, nrow=3)
ES.w2(prob)
pwr.chisq.test(w=.1853,df=2, sig.level=.05, power=.9)
library(pwr)
es <- seq(.1, .5, .01)
nes <- length(es)
samsize <- NULL
for(i in 1:nes){
result <- pwr.anova.test(k=5, f=es[i], sig.level=.05, power=.9)
samsize[i] <- ceiling(result$n)
}
plot(samsize,es, type="l", lwd=2, col="red",ylab="Effect Size",xlab="Sample size (per cell)",
main="One Way ANOVA with Power=.90 and Alpha=.05")
# 生成一系列相关系数和功效值
library (pwr)
r <- seq(.1, .5,.01)
nr <- length(r)
p <- seq(.4,.9,.1)
np <- length(p)
# 获取样本大小
samsize <- array(numeric(nr*np), dim=c (nr,np))
for (i in 1:np){
for (j in 1:nr){
result <- pwr.r.test(n = NULL, r=r[j], sig.level = .05, power = p[i],
alternative = "two.sided")
samsize[j,i] <- ceiling(result$n)
}
}
# 创建图形
xrange <- range(r)
yrange <- round(range(samsize))
colors <- rainbow(length(p))
plot(xrange, yrange, type="n",xlab="Correlation Coefficient (r)", ylab="Sample Size (n)" )
# 添加功效曲线
for (i in 1:np){
lines(r, samsize[,i],type="l",lwd=2, col=colors[i])
}
# 添加网格线
abline(v=O, h=seq(0, yrange[2],50), lty=2, col="grey89")
# 生成一系列相关系数和功效值
library (pwr)
r <- seq(.1, .5,.01)
nr <- length(r)
p <- seq(.4,.9,.1)
np <- length(p)
# 获取样本大小
samsize <- array(numeric(nr*np), dim=c (nr,np))
for (i in 1:np){
for (j in 1:nr){
result <- pwr.r.test(n = NULL, r=r[j], sig.level = .05, power = p[i],
alternative = "two.sided")
samsize[j,i] <- ceiling(result$n)
}
}
# 创建图形
xrange <- range(r)
yrange <- round(range(samsize))
colors <- rainbow(length(p))
plot(xrange, yrange, type="n",xlab="Correlation Coefficient (r)", ylab="Sample Size (n)" )
# 添加功效曲线
for (i in 1:np){
lines(r, samsize[,i],type="l",lwd=2, col=colors[i])
}
# 添加网格线
abline(v=0, h=seq(0, yrange[2],50), lty=2, col="grey89")
abline(h=0, v=seq(xrange [1],xrange [2],.02), lty=2, col="gray89")
# 添加注释
title("Sample Size Estimation for Correlation Studies\nSig=0.05 (Two-tailed)")
legend("topright", title="Power", as.character(p),fill=colors)
install.packages('coin')
install.packages('lmPerm')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(coin)
score <- с(40, 57, 45, 55, 58, 57, 64, 55, 62, 65)
library(coin)
score <- c(40, 57, 45, 55, 58, 57, 64, 55, 62, 65)
treatment <- factor(c(rep("A",5), rep("B",5)))
mydata <- data.frame(treatment, score)
t.test(score~treatment, data=mydata, var.equal=TRUE)
oneway_test(score~treatment, data=mydata, distribution="exact")
library(MASS)
UScrime <- transform(UScrime, So = factor(So))
wilcox_test(Prob ~ So, data=UScrime, distribution="exact")
library(multcomp)
set.seed(1234)
oneway_test(response~trt, data=cholesterol,distribution=approximate(B=9999))
library(coin)
library(vcd)
Arthritis <- transform(Arthritis,Improved=as.factor(as.numeric(Improved)))
set.seed(1234)
chisq_test(Treatment~Improved, data=Arthritis,distribution=approximate(B=9999))
states <- as.data.frame(state.x77)
set.seed(1234)
spearman_test(Illiteracy~Murder, dataestates,distribution=approximate(B=9999))
states <- as.data.frame(state.x77)
set.seed(1234)
spearman_test(Illiteracy~Murder, data=states,distribution=approximate(B=9999))
library(coin)
library(MASS)
wilcoxsign_test(U1~U2, data=UScrime, distribution="exact")
library (lmPerm)
set.seed (1234)
fit1 <- lmp(weight~height, data=women, perm="Prob")
summary(fit1)
library(lmPerm)
set.seed (1234)
fit2 <- lmp (weight~height + I(height^2), data=women, perm="Prob")
summary(fit2)
library(lmPerm)
set.seed(1234)
states <- as.data.frame(state.x77)
fit3 <- lmp(Murder~Population + Illiteracy + Income + Frost, data=states, perm="Prob")
summary(fit3)
library(lmPerm)
library(multcomp)
set.seed(1234)
fit4 <- aovp(response~trt, data=cholesterol, perm="Prob")
anova(fit4)
library(lmPerm)
set.seed(1234)
fit5 <- aovp(weight ~ gesttime + dose, data=litter, perm="Prob")
anova(fit5)
library(lmPerm)
set.seed(1234)
fit6 <- aovp(len~supp*dose, data=ToothGrowth, perme="Prob")
anova(fit6)
install.packages('boot')
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=rsq,R=1000, formula=mpg~wt+disp)
rsq <- function(formula, data, indices){
d <- data[indices, ]
fit <- lm(formula, data=d)
return(summary(fit)$r.square)
}
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=rsq,R=1000, formula=mpg~wt+disp)
# boot的对象可以输出
print(results)
plot(results)
boot.ci(results, type=c("perc", "bca"))
bs <- function(formula, data, indices){
d <- data[indices, ]
fit <- lm(formula, data=d)
return(coef(fit))
}
# 然后使用该函数自助抽样1000次
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=bs,R=1000, formula=mpg~wt+disp)
print(results)
plot(results, index=2)
boot.ci(results, type="bca", index=2)
boot.ci(results, type="bca", index=2)
boot.ci(results, type="bca", index=3)
