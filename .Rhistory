women$weight
fitted(fit)
residuals(fit)
plot(women$height,women$weight, xlab="Height (in inches)", ylab="Weight (in pounds)")
abline(fit)
fit2 <- lm(weight ~ height + I(height^2),data=women)
summary(fit2)
plot(women$height,women$weight, xlab="Height (in inches)", ylab="Weight (in lbs)")
lines(women$height,fitted(fit2))
library(car)
scatterplot(weight ~ height,data=women, spread=FALSE,smoother.args=list(lty=2),pch=19,
main="Women Age 30-39", xlab="Height (inches)", ylab="Weight (1bs.)")
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
states
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
head(states)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
cor(states)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
cor(states)
library(car)
scatterplotMatrix(states, spread=FALSE, smoother.args=list(lty=2),main="Scatter Plot Matrix")
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
summary(fit)
fit <- lm(mpg ~ hp + wt + hp:wt,data=mtcars)
summary(fit)
fit1 <- lm(weight ~ height,data=women)
summary(fit1)
women$weight
fitted(fit1)
residuals(fit1)
plot(women$height,women$weight, xlab="Height (in inches)", ylab="Weight (in pounds)")
abline(fit1)
fit2 <- lm(weight ~ height + I(height^2),data=women)
summary(fit2)
plot(women$height,women$weight, xlab="Height (in inches)", ylab="Weight (in lbs)")
lines(women$height,fitted(fit2))
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
summary(fit4)
fit5 <- lm(mpg ~ hp + wt + hp:wt,data=mtcars)
summary(fit5)
library(effects)
plot(effect("hp:wt",fit,,list(wt=c(2.2,3.2,4.2))),multiline=TRUE)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
confint(fit4)
fit6 <- lm(weight ~ height,data=women)
par(mfrow=c(2,2))
plot(fit6)
fit2 <- lm(weight ~ height + I(height^2),data=women)
par(mfrow=c(2,2))
plot(fit2)
newfit <- lm(weight ~ height + I(height^2),data=women[-c(13,15),])
par(mfrow=c(2,2))
plot(newfit)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
par(mfrow=c(2,2))
plot(fit4)
library(car)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
qqplot(fit4,labels=row.names(states),id.method="identify",simulate=TRUE,main="Q-Q Plot")
library(car)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
qqPlot(fit4,labels=row.names(states),id.method="identify",simulate=TRUE,main="Q-Q Plot")
states["Nevada",]
fitted(fit4)["Nevada"]
residuals(fit4)["Nevada"]
rstudent(fit4)["Nevada"]
residplot <- function(fit7,nbreaks=10){
z <- rstudent(fit7)
hist(z,breaks=nbreaks,freq=FALSE,
xlab="Studentized Residual", main="Distribution of Errors")
rug(jitter(z),col="brown")
curve(dnorm(x,mean=mean(z),sd=sd(z)),
add=TRUE,col="blue",lwd=2)
lines(density(z)$x,density(z)$y,
col="red",lwd=2,lty=2)
legend("topright",
legend = c("Normal Curve","Kernel Density Curve"),
lty=1:2,col=c("blue","red"),cex=.7)
}
residplot(fit7)
residplot <- function(fit,nbreaks=10){
z <- rstudent(fit)
hist(z,breaks=nbreaks,freq=FALSE,
xlab="Studentized Residual", main="Distribution of Errors")
rug(jitter(z),col="brown")
curve(dnorm(x,mean=mean(z),sd=sd(z)),
add=TRUE,col="blue",lwd=2)
lines(density(z)$x,density(z)$y,
col="red",lwd=2,lty=2)
legend("topright",
legend = c("Normal Curve","Kernel Density Curve"),
lty=1:2,col=c("blue","red"),cex=.7)
}
residplot(fit)
durbinWatsonTest(fit)
library(car)
crPlots(fit)
residplot <- function(fit,nbreaks=10){
z <- rstudent(fit)
hist(z,breaks=nbreaks,freq=FALSE,
xlab="Studentized Residual", main="Distribution of Errors")
rug(jitter(z),col="brown")
curve(dnorm(x,mean=mean(z),sd=sd(z)),
add=TRUE,col="blue",lwd=2)
lines(density(z)$x,density(z)$y,
col="red",lwd=2,lty=2)
legend("topright",
legend = c("Normal Curve","Kernel Density Curve"),
lty=1:2,col=c("blue","red"),cex=.7)
}
residplot(fit)
library(car)
crPlots(fit)
library(car)
ncvTest(fit)
library(car)
ncvTest(fit)
spreadLevelplot(fit)
library(car)
ncvTest(fit)
spreadLevelPlot(fit)
residplot <- function(fit4,nbreaks=10){
z <- rstudent(fit4)
hist(z,breaks=nbreaks,freq=FALSE,
xlab="Studentized Residual", main="Distribution of Errors")
rug(jitter(z),col="brown")
curve(dnorm(x,mean=mean(z),sd=sd(z)),
add=TRUE,col="blue",lwd=2)
lines(density(z)$x,density(z)$y,
col="red",lwd=2,lty=2)
legend("topright",
legend = c("Normal Curve","Kernel Density Curve"),
lty=1:2,col=c("blue","red"),cex=.7)
}
residplot(fit4)
durbinWatsonTest(fit4)
library(car)
crPlots(fit4)
library(car)
ncvTest(fit4)
spreadLevelPlot(fit4)
library(gvlma)
install.packages('gvlma')
library(gvlma)
gvmodel <- gvlma(fit4)
summary(gvmodel)
library(car)
vif(fit4)
sqrt(vif(fit4)) > 2 # problem?
library(car)
outlierTest(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(l:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit), names(hatvalues(fit4)))
}
hat.plot(fit4)
hat.plot <- function(fit4){
p <- length(coefficients(fit4))
n <- length(fitted(fit4))
plot(hatvalues(fit4), main="Index plot of Hat Values")
abline(h=c(2,3)*p/n,col="red",lty=2)
identify(1:n,hatvalues(fit4), names(hatvalues(fit4)))
}
hat.plot(fit4)
cutoff <- 4/(nrow(states) - length(fitscoefficients)-2)
cutoff <- 4/(nrow(states) - length(fit$coefficients)-2)
plot(fit4,which=4,cook.levels=cutoff)
abline(h=cutoff,lty=2,col="red")
library(car)
avPlots(fit4,ask=FALSE,id.method="identify")
library(car)
influenceplot(fit4,id.method="identify",main="Influence Plot",sub="Circle size is proportional to Cook's distance")
library(car)
influencePlot(fit4,id.method="identify",main="Influence Plot",sub="Circle size is proportional to Cook's distance")
library(car)
boxTidwell(Murder~Population+Illiteracy,data = states)
library(car)
summary(powerTransform(states$Murder))
library(car)
boxTidwell(Murder~Population+Illiteracy,data = states)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
anova(fit7,fit4)
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
AIC(fit4,fit7)
library(MASS)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
stepAIC(fit4,direction="backward")
install.packages('leaps')
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot (leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
library(car)
subsets(leaps,statistic="cp",main="Cp Plot for All Subsets Regression")
subsets
?subsets
library(leaps)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
leaps <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost,data=states,nbest=4)
plot(leaps,scale="adjr2")
install.packages('bootstrap')
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fitsmodel[,2:ncol(fit$model)]
y <- fitsmodel[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fitsfitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fitsmodel[,2:ncol(fit$model)]
y <- fitsmodel[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,resultsscv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,result$scv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit4 <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x) %*% fit4$coef}
x <- fit4$model[,2:ncol(fit4$model)]
y <- fit4$model[,1]
results <- crossval(x,y,theta.fit4,theta.predict,ngroup=k)
r2 <- cor(y,fit4$fitted.values)^2
r2cv <- cor(y,results$cv.fit4)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
zstates <- as.data.frame(scale(states))
zfit <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=zstates)
coef(zfit)
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar,2:nvar]
rxy <- R[2:nvar,1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda^2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^2)
rawwgt <- lambdasq %*% beta^2
import <- (rawwgt / rsquare)*100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1,drop=FALSE]
dotchart(import$Weights,labels=row.names(import),
xlab="% of R-Square",pch=19,main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=",round(rsquare,digits=3)),...)
return(import)
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
relweights(fit4,col="blue")
library(effects)
plot(effect("hp:wt",fit5,,list(wt=c(2.2,3.2,4.2))),multiline=TRUE)
cutoff <- 4/(nrow(states) - length(fit4$coefficients)-2)
plot(fit4,which=4,cook.levels=cutoff)
abline(h=cutoff,lty=2,col="red")
install.packages('rrcov')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(mvoutlier)
outliers <- aq.plot(y)
center <- colMeans(y)
center <- colMeans(y)
library(MASS)
attach(UScereal)
shelf <- factor(shelf) # 将shelf变量转换为因子变量, 从而使它在后续分析中能作为分组变量
y <- cbind(calories, fat, sugars) # cbind() 函数将三个因变量(卡路里、脂肪和糖)合并成一个矩阵
aggregate(y, by=list(shelf), FUN=mean) # aggregate()函数可获取货架的各个均值
options(digits = 3)
cov(y) # cov()则输出各谷物间的方差和协方差
fit <- manova(y ~ shelf) # manova()函数能对组间差异进行多元检验。
summary(fit)
summary.aov(fit) # 输出单变量结果。由于多元检验是显著的，可以使用summary.aov()函数对每一个变量做单因素方差分析
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
text(coord$x, coord$y,
row.names(UScereal),
cex=1, pos=2, col="red")
library(mvoutlier)
outliers <- aq.plot(y)
outliers
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(rrcov)
Wilks.test(y,shelf,method="mcd")
