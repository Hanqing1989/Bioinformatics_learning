cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,result$scv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit4,k=10){
require(bootstrap)
theta.fit4 <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit4,x){cbind(1,x) %*% fit4$coef}
x <- fit4$model[,2:ncol(fit4$model)]
y <- fit4$model[,1]
results <- crossval(x,y,theta.fit4,theta.predict,ngroup=k)
r2 <- cor(y,fit4$fitted.values)^2
r2cv <- cor(y,results$cv.fit4)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit4$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
shrinkage <- function(fit,k=10){
require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x) %*% fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x,y,theta.fit,theta.predict,ngroup=k)
r2 <- cor(y,fit$fitted.values)^2
r2cv <- cor(y,results$cv.fit)^2
cat("Original R-square =",r2,"\n")
cat(k,"Fold Cross-Validated R-square =",r2cv,"\n")
cat("Change =",r2-r2cv,"\n")
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
shrinkage(fit4)
fit7 <- lm(Murder ~ Population + Illiteracy,data=states)
shrinkage(fit7)
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
zstates <- as.data.frame(scale(states))
zfit <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=zstates)
coef(zfit)
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar,2:nvar]
rxy <- R[2:nvar,1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda^2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^2)
rawwgt <- lambdasq %*% beta^2
import <- (rawwgt / rsquare)*100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1,drop=FALSE]
dotchart(import$Weights,labels=row.names(import),
xlab="% of R-Square",pch=19,main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=",round(rsquare,digits=3)),...)
return(import)
}
states <- as.data.frame(state.x77[,c("Murder","Population","Illiteracy","Income","Frost")])
fit4 <- lm(Murder ~ Population + Illiteracy + Income + Frost,data=states)
relweights(fit4,col="blue")
library(effects)
plot(effect("hp:wt",fit5,,list(wt=c(2.2,3.2,4.2))),multiline=TRUE)
cutoff <- 4/(nrow(states) - length(fit4$coefficients)-2)
plot(fit4,which=4,cook.levels=cutoff)
abline(h=cutoff,lty=2,col="red")
install.packages('rrcov')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(mvoutlier)
outliers <- aq.plot(y)
center <- colMeans(y)
center <- colMeans(y)
library(MASS)
attach(UScereal)
shelf <- factor(shelf) # 将shelf变量转换为因子变量, 从而使它在后续分析中能作为分组变量
y <- cbind(calories, fat, sugars) # cbind() 函数将三个因变量(卡路里、脂肪和糖)合并成一个矩阵
aggregate(y, by=list(shelf), FUN=mean) # aggregate()函数可获取货架的各个均值
options(digits = 3)
cov(y) # cov()则输出各谷物间的方差和协方差
fit <- manova(y ~ shelf) # manova()函数能对组间差异进行多元检验。
summary(fit)
summary.aov(fit) # 输出单变量结果。由于多元检验是显著的，可以使用summary.aov()函数对每一个变量做单因素方差分析
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y,center,cov)
coord <- qqplot(qchisq(ppoints(n),df=p),
d, main="Q-Q Plot Assessing Multivariate Normality",
ylab="Mahalanobis D2")
abline(a=0,b=1)
text(coord$x, coord$y,
row.names(UScereal),
cex=1, pos=2, col="red")
library(mvoutlier)
outliers <- aq.plot(y)
outliers
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(rrcov)
Wilks.test(y,shelf,method="mcd")
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(rrcov)
Wilks.test(y,shelf,method="mcd")
library(multcomp)
levels(cholesterol$trt)
fit.aov <- aov(response ~ trt,data=cholesterol)
summary(fit.aov)
fit.lm <- lm(response ~ trt,data=cholesterol)
summary(fit.lm)
contrasts(cholesterol$trt)
install.packages('pwr')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(pwr)
pwr.t.test(d=.8, sig.level=.05, power=.9, type="two.sample",alternative="two.sided")
pwr.t.test(n=20, d=.5, sig.level=.01, type="two.sample",alternative="two.sided" )
pwr.anova.test(k=5, f=.25, sig.level=.05, power=.8)
pwr.r.test(r=.25, sig.level=.05, power=.90, alternative-"greater")
pwr.r.test(r=.25, sig.level=.05, power=.90, alternative="greater")
pwr.f2.test(u=3, f2=0.0769, sig.level=0.05, power=0.90)
pwr.2p.test(h=ES.h(.65,.6), sig.level=.05, power=.9,alternative="greater")
prob <- matrix(c(.42, .28, .03, .07, .10, .10), byrow=TRUE, nrow=3)
ES.w2(prob)
pwr.chisq.test(w=.1853,df=2, sig.level=.05, power=.9)
library(pwr)
es <- seq(.1, .5, .01)
nes <- length(es)
samsize <- NULL
for(i in 1:nes){
result <- pwr.anova.test(k=5, f=es[i], sig.level=.05, power=.9)
samsize[i] <- ceiling(result$n)
}
plot(samsize,es, type="l", lwd=2, col="red",ylab="Effect Size",xlab="Sample size (per cell)",
main="One Way ANOVA with Power=.90 and Alpha=.05")
# 生成一系列相关系数和功效值
library (pwr)
r <- seq(.1, .5,.01)
nr <- length(r)
p <- seq(.4,.9,.1)
np <- length(p)
# 获取样本大小
samsize <- array(numeric(nr*np), dim=c (nr,np))
for (i in 1:np){
for (j in 1:nr){
result <- pwr.r.test(n = NULL, r=r[j], sig.level = .05, power = p[i],
alternative = "two.sided")
samsize[j,i] <- ceiling(result$n)
}
}
# 创建图形
xrange <- range(r)
yrange <- round(range(samsize))
colors <- rainbow(length(p))
plot(xrange, yrange, type="n",xlab="Correlation Coefficient (r)", ylab="Sample Size (n)" )
# 添加功效曲线
for (i in 1:np){
lines(r, samsize[,i],type="l",lwd=2, col=colors[i])
}
# 添加网格线
abline(v=O, h=seq(0, yrange[2],50), lty=2, col="grey89")
# 生成一系列相关系数和功效值
library (pwr)
r <- seq(.1, .5,.01)
nr <- length(r)
p <- seq(.4,.9,.1)
np <- length(p)
# 获取样本大小
samsize <- array(numeric(nr*np), dim=c (nr,np))
for (i in 1:np){
for (j in 1:nr){
result <- pwr.r.test(n = NULL, r=r[j], sig.level = .05, power = p[i],
alternative = "two.sided")
samsize[j,i] <- ceiling(result$n)
}
}
# 创建图形
xrange <- range(r)
yrange <- round(range(samsize))
colors <- rainbow(length(p))
plot(xrange, yrange, type="n",xlab="Correlation Coefficient (r)", ylab="Sample Size (n)" )
# 添加功效曲线
for (i in 1:np){
lines(r, samsize[,i],type="l",lwd=2, col=colors[i])
}
# 添加网格线
abline(v=0, h=seq(0, yrange[2],50), lty=2, col="grey89")
abline(h=0, v=seq(xrange [1],xrange [2],.02), lty=2, col="gray89")
# 添加注释
title("Sample Size Estimation for Correlation Studies\nSig=0.05 (Two-tailed)")
legend("topright", title="Power", as.character(p),fill=colors)
install.packages('coin')
install.packages('lmPerm')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(coin)
score <- с(40, 57, 45, 55, 58, 57, 64, 55, 62, 65)
library(coin)
score <- c(40, 57, 45, 55, 58, 57, 64, 55, 62, 65)
treatment <- factor(c(rep("A",5), rep("B",5)))
mydata <- data.frame(treatment, score)
t.test(score~treatment, data=mydata, var.equal=TRUE)
oneway_test(score~treatment, data=mydata, distribution="exact")
library(MASS)
UScrime <- transform(UScrime, So = factor(So))
wilcox_test(Prob ~ So, data=UScrime, distribution="exact")
library(multcomp)
set.seed(1234)
oneway_test(response~trt, data=cholesterol,distribution=approximate(B=9999))
library(coin)
library(vcd)
Arthritis <- transform(Arthritis,Improved=as.factor(as.numeric(Improved)))
set.seed(1234)
chisq_test(Treatment~Improved, data=Arthritis,distribution=approximate(B=9999))
states <- as.data.frame(state.x77)
set.seed(1234)
spearman_test(Illiteracy~Murder, dataestates,distribution=approximate(B=9999))
states <- as.data.frame(state.x77)
set.seed(1234)
spearman_test(Illiteracy~Murder, data=states,distribution=approximate(B=9999))
library(coin)
library(MASS)
wilcoxsign_test(U1~U2, data=UScrime, distribution="exact")
library (lmPerm)
set.seed (1234)
fit1 <- lmp(weight~height, data=women, perm="Prob")
summary(fit1)
library(lmPerm)
set.seed (1234)
fit2 <- lmp (weight~height + I(height^2), data=women, perm="Prob")
summary(fit2)
library(lmPerm)
set.seed(1234)
states <- as.data.frame(state.x77)
fit3 <- lmp(Murder~Population + Illiteracy + Income + Frost, data=states, perm="Prob")
summary(fit3)
library(lmPerm)
library(multcomp)
set.seed(1234)
fit4 <- aovp(response~trt, data=cholesterol, perm="Prob")
anova(fit4)
library(lmPerm)
set.seed(1234)
fit5 <- aovp(weight ~ gesttime + dose, data=litter, perm="Prob")
anova(fit5)
library(lmPerm)
set.seed(1234)
fit6 <- aovp(len~supp*dose, data=ToothGrowth, perme="Prob")
anova(fit6)
install.packages('boot')
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=rsq,R=1000, formula=mpg~wt+disp)
rsq <- function(formula, data, indices){
d <- data[indices, ]
fit <- lm(formula, data=d)
return(summary(fit)$r.square)
}
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=rsq,R=1000, formula=mpg~wt+disp)
# boot的对象可以输出
print(results)
plot(results)
boot.ci(results, type=c("perc", "bca"))
bs <- function(formula, data, indices){
d <- data[indices, ]
fit <- lm(formula, data=d)
return(coef(fit))
}
# 然后使用该函数自助抽样1000次
library(boot)
set.seed(1234)
results <- boot(data=mtcars, statistic=bs,R=1000, formula=mpg~wt+disp)
print(results)
plot(results, index=2)
boot.ci(results, type="bca", index=2)
boot.ci(results, type="bca", index=2)
boot.ci(results, type="bca", index=3)
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
plot(predict(model,type="response"), residuals (model,type="deviance"))
install.packages("AER")
library(AER)
data(Affairs)
summary(Affairs)
library(AER)
data(Affairs)
summary(Affairs)
table(Affairs$affairs)
Affairs$ynaffair[Affairs$affairs > 0] <- 1
Affairs$ynaffair[Affairs$affairs ==0] <- 0
Affairs$ynaffair <- factor(Affairs$ynaffair,levels=c(0,1),labels=c("No","Yes"))
table(Affairs$ynaffair)
fit.full <- glm(ynaffair ~ gender + age + yearsmarried + children + religiousness +
education + occupation + rating, data=Affairs,family=binomial())
summary(fit.full)
fit.reduced <- glm(ynaffair ~ age + yearsmarried + religiousness + rating,data=Affairs,family=binomial())
summary(fit.reduced)
anova(fit.reduced,fit.full,test="Chisq")
coef(fit.reduced)
exp(coef(fit.reduced))
testdata <- data.frame(rating=c(1,2,3,4,5),age=mean(Affairs$age),
yearsmarried=mean (Affairs$yearsmarried),religiousness=mean(Affairs$religiousness))
testdata
testdata$prob <- predict(fit.reduced,newdata=testdata,type="response")
testdata
testdata <- data.frame(rating=mean(Affairs$rating),
age=seg(17,57,10),yearsmarried=mean(Affairs$yearsmarried),
religiousness=mean(Affairs$religiousness))
testdata <- data.frame(rating=mean(Affairs$rating),
age=seq(17,57,10),yearsmarried=mean(Affairs$yearsmarried),
religiousness=mean(Affairs$religiousness))
testdata
testdata <- data.frame(rating=mean(Affairs$rating),
age=seq(17,57,10),yearsmarried=mean(Affairs$yearsmarried),
religiousness=mean(Affairs$religiousness))
testdata
testdata$prob <- predict(fit.reduced,newdata=testdata,type="response")
testdata
deviance(fit.reduced)/df.residual(fit.reduced)
pchisq(summary(fit.od)$dispersion * fitsdf.residual, fit$df.residual,lower = F)
fit1 <-glm(ynaffair ~ age yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
fit1 <-glm(ynaffair ~ age yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
fit <- glm(ynaffair ~ age yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
deviance(fit.reduced)/df.residual(fit.reduced)
fit <- glm(ynaffair ~ age yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
fit <- glm(ynaffair ~ age + yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
fit.od <- glm(ynaffair ~ age + yearsmarried + religiousness + rating,
family = quasibinomial(),data = Affairs)
pchisq(summary(fit.od)$dispersion * fitsdf.residual,fit$df.residual,lower = F)
fit <- glm(ynaffair ~ age + yearsmarried + religiousness + rating,family = binomial(),data = Affairs)
fit.od <- glm(ynaffair ~ age + yearsmarried + religiousness + rating,
family = quasibinomial(),data = Affairs)
pchisq(summary(fit.od)$dispersion * fit$df.residual,fit$df.residual,lower = F)
install.packages('robust')
data(breslow.dat,package="robust")
names(breslow.dat)
data(breslow.dat,package="robust")
names(breslow.dat)
summary(breslow.dat[c(6,7,8,10)]
data(breslow.dat,package="robust")
names(breslow.dat)
summary(breslow.dat[c(6,7,8,10)])
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2))
attach(breslow.dat)
hist(sumY,breaks=20,xlab="Seizure Count",main="Distribution of Seizures")
boxplot(sumY ~ Trt,xlab="Treatment",main="Group Comparisons")
par(opar)
fit1 <-glm(sumY ~ Base + Age + Trt,data=breslow.dat,family=poisson())
summary(fit1)
coef(fit1)
exp(coef(fit1))
deviance(fit1)/df.residual(fit1)
install.packages('qcc')
library(qcc)
qcc.overdispersion.test(breslow.datssumy,type="poisson")
library(qcc)
qcc.overdispersion.test(breslow.dat$sumy,type="poisson")
library(qcc)
qcc.overdispersion.test(breslow.dat$sumY,type="poisson")
fit.od <- glm(sumY ~ Base + Age + Trt,data=breslow.dat,family=quasipoisson())
summary(fit.od)
install.packages('psych')
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(psych)
fa.parallel(USJudgeRatings[,-1],fa="pc",n.iter=100,
show.legend=FALSE,main="Scree plot with parallel analysis")
library(psych)
pc <- principal(USJudgeRatings[,-1],nfactors=1)
pc
library(psych)
pc <- principal(USJudgeRatings[,-1],nfactors=1)
head(pc)
library(psych)
pc <- principal(USJudgeRatings[,-1],nfactors=1)
pc
library(psych)
fa.parallel(Harman23.corscov,n.obs=302,fa="pc",n.iter=100,show.legend=FALSE,main="Scree plot with parallel analysis")
library(psych)
fa.parallel(Harman23.cor$cov,n.obs=302,fa="pc",n.iter=100,show.legend=FALSE,main="Scree plot with parallel analysis")
library(psych)
pc1 <- principal(USJudgeRatings[,-1],nfactors=1)
pc1
library(psych)
pc2 <-principal(Harman23.cor$cov,nfactors=2,rotate="none")
pc2
rc1 <-principal(Harman23.cor$cov,nfactors=2,rotate="varimax")
rc1
library(psych)
pc2 <- principal(USJudgeRatings[,-1],nfactors=1,score=TRUE)
head(pc$scores)
cor(USJudgeRating$SCONT,pc2$score)
cor(USJudgeRatings$CONT,pc2$score)
library(psych)
rc2 <- principal(Harman23.cor$cov,nfactors=2,rotate="varimax")
round(unclass(rc2$weights),2)
PC1 = 0.28*height + 0.30*arm.span + 0.30*forearm + 0.29*lower.leg -
0.06*weight - 0.08*bitro.diameter - 0.10*chest.girth - 0.04*chest.width
options(digits=2)
covariances <- ability.covscov
options(digits=2)
covariances <- ability.cov$cov
correlations <- cov2cor(covariances)
correlations
library(psych)
covariances <- ability.covscov
library(psych)
covariances <- ability.cov$cov
correlations <- cov2cor(covariances)
fa.parallel(correlations,n.obs=112,fa="both",n.iter=100,
main="Scree plots with parallel analysis")
