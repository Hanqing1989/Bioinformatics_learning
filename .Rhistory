head(pc2$scores)
cor(USJudgeRatings$CONT,pc2$score)
library(psych)
rc2 <- principal(Harman23.cor$cov,nfactors=2,rotate="varimax")
round(unclass(rc2$weights),2)
options(digits=2)
covariances <- ability.cov$cov
correlations <- cov2cor(covariances)
correlations
fa <-fa(correlations,nfactors=2,rotate="none",fm="pa")
fa
fa.varimax <- fa(correlations,nfactors=2,rotate="varimax",fm="pa")
fa.varimax
fa.promax <- fa(correlations,nfactors=2,rotate="promax",fm="pa")
fa.promax <- fa(correlations,nfactors=2,rotate="promax",fm="pa")
fa.varimax <- fa(correlations,nfactors=2,rotate="varimax",fm="pa")
fa.varimax
fa.promax <- fa(correlations,nfactors=2,rotate="promax",fm="pa")
install.packages('GPArotation')
fa.promax <- fa(correlations,nfactors=2,rotate="promax",fm="pa")
fa.promax
fsm <-function (oblique){
if (class(oblique)[2]=="fa" & is.null(oblique$Phi)){
warning("Object doesn't look like oblique EFA")
} else {
P <- unclass(oblique$loading)
F <- P %*% oblique$Phi
colnames(F) <- c("PA1","PA2")
return(F)
}
}
fsm(fa.promax)
factor.plot(fa.promax,labels=rownames(fa.promax$loadings))
fa.diagram(fa.promax,simple=FALSE)
library(psych)
fa.24tests <- fa(Harman74.corscov,nfactors=4,rotate="promax")
library(psych)
fa.24tests <- fa(Harman74.cor$cov,nfactors=4,rotate="promax")
fa.promax$weights
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
# 生成时序对象
sales <- c(18,33,41,7,34,35,24,25,24,21,25,20,22,31,40,29,25,21,22,54,31,25,26,35)
tsales <- ts(sales,start=c(2003,1),frequency=12)
tsales
# 生成时序对象
sales <- c(18,33,41,7,34,35,24,25,24,21,25,20,22,31,40,29,25,21,22,54,31,25,26,35)
tsales <- ts(sales,start=c(2003,1),frequency=12)
tsales
# 获得这个对象的信息
plot(tsales)
start(tsales)
end(tsales)
frequency(tsales)
# 对对象取子集
tsales.subset <- window(tsales,start=c(2003,5),end=c(2004,6))
tsales.subset
install.packages('forecast')
library(forecast)
library(forecast)
library(forecast)
install.packages("forecast")
library(forecast)
library(forecast)
library(forecast)
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
library(forecast)
library(forecast)
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
pkgs <-c("rpart","rpart.plot","party", "randomForest","e1071")
install.packages(pkgs,depend=TRUE)
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
ds <- "breast-cancer-wisconsin/breast-cancer-wisconsin.data"
url <- paste(loc,ds,sep="")
breast <- read.table(url,sep=",",header=FALSE,na.strings="?")
names(breast) <- c("ID","clumpThickness","sizeUniformity","shapeUniformity","maginalAdhesion",
"singleEpithelialCellsize","bareNuclei","blandchromatin","normalNucleoli",
"mitosis","class")
df <- breast[-1]
df$class <- factor(df$class,levels=c(2,4),labels=c("benign","malignant"))
set.seed(1234)
train <- sample(nrow(df),0.7*nrow(df))
df.train <- df[train,]
df.validate <- df[-train,]
table(df.train$class)
table(df.validate$class)
# 拟合逻辑回归
fit.logit <- glm(class~.,data=df.train,family=binomial())
summary(fit.logit)
# 拟合逻辑回归
fit.logit <- glm(class~.,data=df.train,family=binomial())
# 检查模型
summary(fit.logit)
# 对训练集集外样本单元分类
prob <- predict(fit.logit,df.validate,type="response")
logit.pred <- factor(prob >.5,levels=c(FALSE,TRUE),labels=c("benign","malignant"))
# 评估预测准确性
logit.perf <- table(df.validatesclass,logit.pred,dnn=c("Actual","Predicted"))
# 拟合逻辑回归
fit.logit <- glm(class~.,data=df.train,family=binomial())
# 检查模型
summary(fit.logit)
# 对训练集集外样本单元分类
prob <- predict(fit.logit,df.validate,type="response")
logit.pred <- factor(prob >.5,levels=c(FALSE,TRUE),labels=c("benign","malignant"))
# 评估预测准确性
logit.perf <- table(df.validate$class,logit.pred,dnn=c("Actual","Predicted"))
logit.perf
# 生成树
library(rpart)
set.seed(1234)
dtree <- rpart(class ~.data=df.train,method="class",parms=list(split="information"))
# 生成树
library(rpart)
set.seed(1234)
dtree <- rpart(class ~.,data=df.train,method="class",parms=list(split="information"))
dtree$cptable
# 生成树
library(rpart)
set.seed(1234)
dtree <- rpart(class ~.,data=df.train,method="class",parms=list(split="information"))
dtree$cptable
plotcp(dtree)
# 剪枝
dtree.pruned <- prune(dtree,cp=.0125)
library(rpart.plot)
prp(dtree.pruned,type = 2,extra = 104,fallen.leaves = TRUE,main="Decision Tree")
# 生成树
library(rpart)
set.seed(1234)
dtree <- rpart(class ~.,data=df.train,method="class",parms=list(split="information"))
dtree$cptable
plotcp(dtree)
# 剪枝
dtree.pruned <- prune(dtree,cp=.0125)
library(rpart.plot)
prp(dtree.pruned,type = 2,extra = 104,fallen.leaves = TRUE,main="Decision Tree")
# 对训练集外样本单元分类
dtree.pred <- predict(dtree.pruned,df.validate,type="class")
dtree.perf <- table(df.validate$class,dtree.pred,dnn=c("Actual","Predicted"))
dtree.perf
library(party)
fit.ctree <- ctree(class~.,data=df.train)
plot(fit.ctree,main="Conditional Inference Tree")
ctree.pred <- predict(fit.ctree,df.validate,type="response")
ctree.perf <- table(df.validate$class,ctree.pred,dnn=c("Actual","Predicted"))
ctree.perf
install.packages('partykit')
# 生成森林
library(randomForest)
set.seed(1234)
fit.forest <- randomForest(class~.,data=df.train,na.action=na.roughfix, importance=TRUE)
fit.forest
# 生成森林
library(randomForest)
set.seed(1234)
fit.forest <- randomForest(class~.,data=df.train,na.action=na.roughfix, importance=TRUE)
fit.forest
# 给出变量重要性
importance(fit.forest,type=2)
# 对训练集外样本点分类
forest.pred <- predict(fit.forest,df.validate)
forest.perf <- table(df.validate$class,forest.pred,dnn=c("Actual","Predicted"))
forest.perf
library(e1071)
set.seed(1234)
fit.svm <- svm(class~.,data=df.train)
fit.svm
svm.pred <- predict(fit.svm,na.omit(df.validate))
svm.perf <- table(na.omit (df.validate)$class,svm.pred,dnn=c("Actual","Predicted"))
svm.perf
# 变换参数
set.seed(1234)
tuned <- tune.svm(class~.,data=df.train,gamma=10^(-6:1),cost=10^(-10:10))
tuned # 输出最优模型
# 用这些参数拟合模型
fit.svm <- svm(class~.,data=df.train,gamma=.01,cost=1)
# 评估交叉验证表现
svm.pred <- predict(fit.svm,na.omit(df.validate))
svm.perf <- table(na.omit(df.validate)$class,svm.pred,dnn=c("Actual","Predicted"))
svm.perf
performance <- function(table,n=2){
if(!all(dim(table)==c(2,2)))
stop("Must be a 2 x 2 table")
tn = table[1,1]
fp = table[1,2]
fn = table[2,1]
tp = table[2,2]
sensitivity = tp/(tp+fn)
specificity = tn/(tn+fp)
ppp = tp/(tp+fp)
npp = tn/(tn+fn)
hitrate = (tp+tn)/(tp+tn+fp+fn)
result <- paste("Sensitivity =", round(sensitivity,n),"\nSpecificity = ",round(specificity,n),
"InPositive Predictive value = ", round(ppp,n),
"\nNegative Predictive Value = ", round(npp,n),
"\nAccuracy = ", round(hitrate,n),"\n",sep="")
cat(result)
}
performance(logit.perf)
performance(logit.perf)
performance(dtree.perf)
performance(ctree.perf)
performance(forest.perf)
performance(logit.perf)
performance(dtree.perf)
performance(ctree.perf)
performance(forest.perf)
performance(svm.perf)
install.packages('rattle')
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
ds <- "pima-indians-diabetes/pima-indians-diabetes.data"
url <- paste(loc,ds,sep="")
diabetes <- read.table(url,sep=",",header=FALSE)
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
ds <- "pima-indians-diabetes/pima-indians-diabetes.data"
url <- paste(loc,ds,sep="")
diabetes <- read.table(url,sep=",",header=FALSE)
library(rattle)
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
ds <- "pima-indians-diabetes/pima-indians-diabetes.data"
url <- paste(loc,ds,sep="")
diabetes <- read.table(url,sep=",",header=FALSE)
library(rattle)
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
ds <- "pima-indians-diabetes/pima-indians-diabetes.data"
url <- paste(loc,ds,sep="")
diabetes <- read.table(url,sep=",",header=FALSE)
knitr::opts_chunk$set(prompt=TRUE,comment='',echo=TRUE,collapse=TRUE,message=FALSE,warning=FALSE)
passed <- c(TRUE,TRUE,FALSE, TRUE)
ages <- c(15,18,25,14,19)
cmplxNums <- c(1+2i,0+1i,39+3i,12+2i)
names <- c("Bob","Ted","Carol","Alice")
x <- c(1,2,3,4,5,6,7,8)
class(x)
print(x)
attr(x,"dim") <- c(2,4)
# 对象x现在变成了matrix类的2×4矩阵
print(x)
attr(x,"dim") <- c(2,4)
# 对象x现在变成了matrix类的2×4矩阵
print(x)
class(x)
attributes(x<!---->)
attr(x,"dim") <- c(2,4)
# 对象x现在变成了matrix类的2×4矩阵
print(x)
class(x)
attributes(x)
attr(x,"dimnames") <- list (c("A1","A2"),c("B1","B2","B3","B4"))
print(x)
attr(x,"dim") < -NULL
attr(x,"dim") <- NULL
class(x)
print(x)
head(iris)
unclass(iris)
attributes(iris)
set.seed(1234)
fit <- kmeans(iris[1:4],3)
names(fit)
names(fit)
unclass(fit)
sapply(fit,class)
x <- c(20,30,40)
x[3]
x[c(2,3)]
x <- c(A=20,B=30,C=40)
x[c(2,3)]
x[c("B","C")]
fit[c(2,7)]
fit[2]
fit[[2]]
fit$centers
fit[[2]][1,]
# 获取聚类均值
set.seed(1234)
fit1 <- kmeans(iris[1:4],3)
means <- fit1$centers
# 重塑数据长表
library(reshape2)
dfm <- melt(means)
names(dfm) <- c("Cluster","Measurement","Centimeters")
dfm$cluster <- factor(dfm$cluster)
# 获取聚类均值
set.seed(1234)
fit1 <- kmeans(iris[1:4],3)
means <- fit1$centers
# 重塑数据长表
library(reshape2)
dfm <- melt(means)
names(dfm) <- c("Cluster","Measurement","Centimeters")
dfm$Cluster <- factor(dfm$Cluster)
head(dfm)
# 获取聚类均值
set.seed(1234)
fit1 <- kmeans(iris[1:4],3)
means <- fit1$centers
# 重塑数据长表
library(reshape2)
dfm <- melt(means)
names(dfm) <- c("Cluster","Measurement","Centimeters")
dfm$Cluster <- factor(dfm$Cluster)
head(dfm)
# 绘制线图
library(ggplot2)
ggplot(data=dfm,aes(x=Measurement,y=Centimeters,group=Cluster)) +
geom_point(size=3,aes(shape=Cluster,color=Cluster)) + geom_line(size=1,aes(color=Cluster)) +
ggtitle("Profiles for Iris Clusters")
3+2+5
3 + 2 +
5
for(i in 1:5)
print(1:i)
for(i in 1:5)
print(1:i)
for(i in 5:1)
print (1:i)
if(interactive()){
plot (x,y)
} else {
png("myplot png")
plot(x,y)
dev.off()
}
pvalues <- c(.0867,.0018,.0054,.1572,.0183,.5386)
results <- ifelse(pvalues <.05,"Significant","Not Significant")
results
results <-vector(mode="character",length=length(pvalues))
for(i in 1:length(pvalues)){
if(pvalues[i]<.05)
results[i] <- "Significant"
else results [i] <- "Not Significant"
}
f <- function(x,y, z=1){
result <- x+(2*y)+(3*z)
return(result)
}
f <- function(x,y, z=1){
result <- x+(2*y)+(3*z)
return(result)
}
f(2,3,4)
f(2,3)
f(x=2,y=3)
f(z=4,y=2,3)
args(f)
x <- 2
y <- 3
z <- 4
f1 <- function(w){
z <-2
x <- w*y*z
return(x)
}
f1(x)
x
y
z
x <- 5
myenv <- new.env()
assign("x","Homer",env=myenv)
ls()
ls(myenv)
x
get("x",env=myenv)
myenv <- new.env()
myenv$x <- "Homer"
myenv$x
parent.env(myenv)
trim <- function(p){
trimit <-function(x){
n <- length(x)
lo <- floor(n*p) + 1
hi <- n + 1 - lo
x <- sort.int(x,partial = unique(c(lo,hi)))[lo:hi]
}
trimit
}
x <- 1:10
trim10pct <- trim(.1)
y <- trim10pct(x)
y
x <- 1:10
trim10pct <- trim(.1)
y <- trim10pct(x)
y
trim20pct <- trim(.2)
y <- trim20pct(x)
y
ls(environment(trim10pct))
get("p",env=environment(trim10pct))
makeFunction <- function(k){
f <- function(x){
print(x + k)
}
}
g <- makeFunction(10)
g(4)
k <- 2
g(5)
ls(environment(g))
environment(g)$k
summary(women)
fit2 <- lm(weight ~ height,data=women)
summary(fit2)
summary
class(women)
class(fit2)
methods(summary)
# 定义泛型函数
mymethod <-function(x,...) UseMethod("mymethod")
mymethod.a <- function(x) print("Using A")
mymethod.b <-function(x) print("Using B")
mymethod.default <- function(x) print("Using Default")
x <- 1:5
y <- 6:10
z <- 10:15
# 给对象分配类
class(x) <- "a"
class(y) <- "b"
# 把泛型函数应用到对象中
mymethod(x)
mymethod(y)
mymethod(z)
# 把泛型函数应用到包含两个类的对象中
class(z) <- c("a","b")
mymethod(z)
# 泛型函数没有默认为"c"的类
class(z) <- c("c","a","b")
mymethod(z)
class(women) <- "lm"
summary(women)
my.data.frame <- read.table(mytextfile,header=TRUE,sep=',',
colClasses=c("numeric","numeric","character",
NULL,"numeric",NULL,"character",NULL,NULL,NULL))
set.seed(1234)
mymatrix <- matrix(rnorm(10000000),ncol=10)
accum <- function(x){
sums <- numeric(ncol(x))
for (i in 1:ncol(x)){
for(j in 1:nrow(x)){
sums[i] <- sums[i] + x[j,i]
}
}
}
system.time(accum(mymatrix))
system.time(colSums(mymatrix))
set.seed(1234)
k <- 100000
x <- rnorm(k)
y <- 0
system.time(for (i in 1:length(x)) y[i] <- x[i]^2)
y <- numeric(length=k)
system.time(for (i in 1:k) y[i] <- x[i]^2)
y <- numeric(length=k)
system.time(y <- x^2)
install.packages('doParallel')
install.packages('foreach')
# 加载包并登记内核数量
library(foreach)
library(doParallel)
registerDoParallel(cores=2)
# 定义函数
eig <- function(n,p){
x <- matrix(rnorm(100000),ncol=100)
r <- cor(x)
eigen(r)$values
}
n <- 1000000
p <- 100
k <- 500
# 正常执行
system.time(
x <- foreach(i=1:k,.combine=rbind) %do% eig(n,p)
)
# 并行执行
system.time(
x <- foreach(i=1:k,.combine=rbind) %dopar% eig(n,p)
)
mtcars$Transmission <- factor(mtcarssa,levels=c(1,2),labels=c("Automatic","Manual"))
mtcars$Transmission <- factor(mtcars$a,levels=c(1,2),labels=c("Automatic","Manual"))
aov(mpg ~ Transmission,data=mtcars)
head(mtcars[c("mpg","Transmission")])
head(mtcars[c("mpg","Transmission")])
table(mtcars$Transmission)
# 查看形式参数
args(mad)
function(x,center = median(x),constant = 1.4826,na.rm = FALSE,low = FALSE,high = FALSE)
NULL
debug(mad)
# 设置调试函数
mad(1:10)
# 查看形式参数
args(mad)
function(x,center = median(x),constant = 1.4826,na.rm = FALSE,low = FALSE,high = FALSE)
NULL
debug(mad)
# 设置调试函数
mad(1:10)
# 列出对象
Browse[2]> ls()
# 查看形式参数
args(mad)
function(x,center = median(x),constant = 1.4826,na.rm = FALSE,low = FALSE,high = FALSE)
NULL
debug(mad)
# 设置调试函数
mad(1:10)
# 列出对象
Browse[2]> ls()
head(mtcars[c("mpg","Transmission")])
table(mtcars$Transmission)
